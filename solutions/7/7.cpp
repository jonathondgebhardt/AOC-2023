// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <algorithm>
#include <gtest/gtest.h>

namespace
{
    enum HandType
    {
        FiveOfAKind,
        FourOfAKind,
        FullHouse,
        ThreeOfAKind,
        TwoPair,
        OnePair,
        HighCard
    };

    struct Hand
    {
        static Hand Build(const std::string& x)
        {
            Hand h;

            const auto tokens = util::Split(x);
            assert(tokens.size() == 2);

            const auto& cards = tokens.front();
            h.mCards = tokens.front();

            h.mBid = util::StringTo<size_t>(tokens.back());

            return h;
        }

        std::string mCards;
        size_t mBid{0};
        HandType mHandType{HandType::HighCard};
    };

    namespace part1
    {
        static std::unordered_map<char, size_t> CardRanks = {
            {'A', 0}, {'K', 1}, {'Q', 2}, {'J', 3},  {'T', 4},  {'9', 5}, {'8', 6},
            {'7', 7}, {'6', 8}, {'5', 9}, {'4', 10}, {'3', 11}, {'2', 12}};

        struct Rules
        {
            static HandType GetHandType(const Hand& x)
            {
                std::unordered_map<char, size_t> cardCounts;

                for(auto i = 0; i != x.mCards.size(); ++i)
                {
                    const auto it = cardCounts.find(x.mCards[i]);
                    if(it != cardCounts.end())
                    {
                        it->second++;
                    }
                    else
                    {
                        cardCounts.insert({x.mCards[i], 1});
                    }
                }

                if(cardCounts.size() == 1)
                {
                    return HandType::FiveOfAKind;
                }
                else if(cardCounts.size() == 2)
                {
                    const auto biggest = std::max_element(cardCounts.begin(), cardCounts.end(),
                                                          [](const auto lhs, const auto rhs)
                                                          { return lhs.second < rhs.second; });
                    return biggest->second == 4 ? HandType::FourOfAKind : HandType::FullHouse;
                }
                else if(cardCounts.size() == 3)
                {
                    const auto biggest = std::max_element(cardCounts.begin(), cardCounts.end(),
                                                          [](const auto lhs, const auto rhs)
                                                          { return lhs.second < rhs.second; });
                    return biggest->second == 3 ? HandType::ThreeOfAKind : HandType::TwoPair;
                }
                else if(cardCounts.size() == 4)
                {
                    return HandType::OnePair;
                }

                return HandType::HighCard;
            }

            bool operator()(const Hand& lhs, const Hand& rhs)
            {
                if(lhs.mHandType != rhs.mHandType)
                {
                    return lhs.mHandType < rhs.mHandType;
                }

                for(auto i = 0; i < lhs.mCards.size(); ++i)
                {
                    if(lhs.mCards[i] != rhs.mCards[i])
                    {
                        const auto lhsRank = CardRanks[lhs.mCards[i]];
                        const auto rhsRank = CardRanks[rhs.mCards[i]];
                        return lhsRank < rhsRank;
                    }
                }

                return false;
            }
        };
    }

    namespace part2
    {
        static std::unordered_map<char, size_t> CardRanks = {
            {'A', 0}, {'K', 1}, {'Q', 2}, {'T', 3},  {'9', 4},  {'8', 5}, {'7', 6},
            {'6', 7}, {'5', 8}, {'4', 9}, {'3', 10}, {'2', 11}, {'J', 12}};

        struct Rules
        {
            static HandType GetHandType(const Hand& x)
            {
                std::unordered_map<char, size_t> cardCounts;

                for(auto i = 0; i != x.mCards.size(); ++i)
                {
                    const auto it = cardCounts.find(x.mCards[i]);
                    if(it != cardCounts.end())
                    {
                        it->second++;
                    }
                    else
                    {
                        cardCounts.insert({x.mCards[i], 1});
                    }
                }

                const auto jokerCount = [&]()
                {
                    if(cardCounts.find('J') != cardCounts.end())
                    {
                        return cardCounts['J'];
                    }

                    return size_t{0};
                }();

                if(jokerCount > 0 && jokerCount < 5)
                {
                    cardCounts.erase('J');
                    auto biggest =
                        std::max_element(cardCounts.begin(), cardCounts.end(),
                                         [](const auto lhs, const auto rhs)
                                         {
                                             if(lhs.second == rhs.second)
                                             {
                                                 return CardRanks[lhs.first] < CardRanks[rhs.first];
                                             }

                                             return lhs.second < rhs.second;
                                         });
                    cardCounts[biggest->first] += jokerCount;
                }

                if(cardCounts.size() == 1)
                {
                    return HandType::FiveOfAKind;
                }
                else if(cardCounts.size() == 2)
                {
                    const auto biggest = std::max_element(cardCounts.begin(), cardCounts.end(),
                                                          [](const auto lhs, const auto rhs)
                                                          { return lhs.second < rhs.second; });
                    return biggest->second == 4 ? HandType::FourOfAKind : HandType::FullHouse;
                }
                else if(cardCounts.size() == 3)
                {
                    const auto biggest = std::max_element(cardCounts.begin(), cardCounts.end(),
                                                          [](const auto lhs, const auto rhs)
                                                          { return lhs.second < rhs.second; });
                    return biggest->second == 3 ? HandType::ThreeOfAKind : HandType::TwoPair;
                }
                else if(cardCounts.size() == 4)
                {
                    return HandType::OnePair;
                }

                return HandType::HighCard;
            }

            bool operator()(const Hand& lhs, const Hand& rhs)
            {
                if(lhs.mHandType != rhs.mHandType)
                {
                    return lhs.mHandType < rhs.mHandType;
                }

                for(auto i = 0; i < lhs.mCards.size(); ++i)
                {
                    if(lhs.mCards[i] != rhs.mCards[i])
                    {
                        const auto lhsRank = CardRanks[lhs.mCards[i]];
                        const auto rhsRank = CardRanks[rhs.mCards[i]];
                        return lhsRank < rhsRank;
                    }
                }

                return false;
            }
        };
    }

    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            std::vector<Hand> hands;
            std::transform(mInput.begin(), mInput.end(), std::back_inserter(hands), Hand::Build);

            for(auto& hand : hands)
            {
                hand.mHandType = part1::Rules::GetHandType(hand);
            }

            std::sort(hands.begin(), hands.end(), part1::Rules());

            int64_t totalWinnings{0};
            for(auto i = 0; i < hands.size(); i++)
            {
                totalWinnings += (hands.size() - i) * hands[i].mBid;
            }

            return totalWinnings;
        }

        Answer solvePartTwo() override
        {
            std::vector<Hand> hands;
            std::transform(mInput.begin(), mInput.end(), std::back_inserter(hands), Hand::Build);

            for(auto& hand : hands)
            {
                hand.mHandType = part2::Rules::GetHandType(hand);
            }

            std::sort(hands.begin(), hands.end(), part2::Rules());

            int64_t totalWinnings{0};
            for(auto i = 0; i < hands.size(); i++)
            {
                totalWinnings += (hands.size() - i) * hands[i].mBid;
            }

            return totalWinnings;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "7_sample.txt" : "7.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_7, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 251058093);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_7, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 249781879);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_7, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 6440);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_7, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 5905);
    std::cout << "[::::::::::] " << *answer << std::endl;
}
