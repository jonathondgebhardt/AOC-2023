// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <gtest/gtest.h>

namespace
{
    namespace part1
    {
        int64_t extrapolate(const std::vector<int64_t>& x)
        {
            assert(!x.empty());

            const auto allZeroes =
                std::all_of(x.begin(), x.end(), [](int64_t d) { return d == int64_t{0}; });
            if(allZeroes)
            {
                return int64_t{0};
            }

            std::vector<int64_t> diff;
            for(auto i = 0; i < x.size() - 1; ++i)
            {
                diff.push_back(x[i + 1] - x[i]);
            }

            return x.back() + extrapolate(diff);
        }
    }

    namespace part2
    {
        int64_t extrapolate(const std::vector<int64_t>& x)
        {
            assert(!x.empty());

            const auto allZeroes =
                std::all_of(x.begin(), x.end(), [](int64_t d) { return d == int64_t{0}; });
            if(allZeroes)
            {
                return int64_t{0};
            }

            std::vector<int64_t> diff;
            for(auto i = 0; i < x.size() - 1; ++i)
            {
                diff.push_back(x[i + 1] - x[i]);
            }

            return x.front() - extrapolate(diff);
        }
    }

    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            int64_t sum{0};
            for(const auto& line : mInput)
            {
                const auto tokens = util::Split(line);
                const auto series = util::ContainerTo<int64_t>(tokens);

                sum += part1::extrapolate(series);
            }

            return sum;
        }

        Answer solvePartTwo() override
        {
            int64_t sum{0};
            for(const auto& line : mInput)
            {
                const auto tokens = util::Split(line);
                const auto series = util::ContainerTo<int64_t>(tokens);

                sum += part2::extrapolate(series);
            }

            return sum;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "9_sample.txt" : "9.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_9, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 1955513104);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_9, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 1131);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_9, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 114);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_9, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 2);
    std::cout << "[::::::::::] " << *answer << std::endl;
}
