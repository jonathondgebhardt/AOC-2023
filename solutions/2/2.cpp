// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <gtest/gtest.h>
#include <numeric>

namespace
{
    constexpr auto RedCube = "red";
    constexpr auto GreenCube = "green";
    constexpr auto BlueCube = "blue";

    struct CubeGame
    {
        static CubeGame Build(const std::string& x)
        {
            CubeGame cg;
            cg.mId = GetGameId(x);

            const auto start = x.find(':') + 1;
            const auto draws = util::Split(x.substr(start), ';');
            for(const auto& draw : draws)
            {
                const auto cubes = util::Split(draw, ',');
                for(const auto& cube : cubes)
                {
                    const auto tokens = util::Split(cube);
                    const auto amount = util::StringTo<size_t>(tokens.front());
                    const auto color = tokens.back();
                    if(color == RedCube)
                    {
                        cg.mValid &= amount <= RedCubeMax;
                        cg.mRedCubes = std::max(cg.mRedCubes, amount);
                    }
                    else if(color == GreenCube)
                    {
                        cg.mValid &= amount <= GreenCubeMax;
                        cg.mGreenCubes = std::max(cg.mGreenCubes, amount);
                    }
                    else if(color == BlueCube)
                    {
                        cg.mValid &= amount <= BlueCubeMax;
                        cg.mBlueCubes = std::max(cg.mBlueCubes, amount);
                    }
                }
            }

            return cg;
        }

        static int64_t GetGameId(const std::string& x)
        {
            // We assume the split string will contain at least two tokens. Avoid a crash.
            if(x.empty())
            {
                return {};
            }

            // The game ID should be the second token.
            // Example: 'Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green'
            const auto id = util::Split(x)[1];

            // Account for the trailing ':'.
            return util::StringTo<int64_t>(id.substr(0, id.size() - 1));
        }

        inline int64_t GetPower() const
        {
            return mRedCubes * mGreenCubes * mBlueCubes;
        }

        // Rules for maximum amount of cubes for a given color.
        static constexpr size_t RedCubeMax{12};
        static constexpr size_t GreenCubeMax{13};
        static constexpr size_t BlueCubeMax{14};

        size_t mId{0};
        bool mValid{true};

        // Describes the fewest number of cubes required by this game.
        size_t mRedCubes{0};
        size_t mGreenCubes{0};
        size_t mBlueCubes{0};
    };

    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            std::vector<CubeGame> games;
            std::transform(mInput.begin(), mInput.end(), std::back_inserter(games),
                           &CubeGame::Build);

            return std::accumulate(games.begin(), games.end(), 0,
                                   [](int64_t sum, const CubeGame& cg)
                                   {
                                       const auto id = cg.mValid ? cg.mId : 0;
                                       return sum + id;
                                   });
        }

        Answer solvePartTwo() override
        {
            std::vector<CubeGame> games;
            std::transform(mInput.begin(), mInput.end(), std::back_inserter(games),
                           &CubeGame::Build);

            return std::accumulate(games.begin(), games.end(), 0,
                                   [](int64_t sum, const CubeGame& cg)
                                   { return sum + cg.GetPower(); });
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "2_sample.txt" : "2.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_2, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 2169);
    std::cout << "part one: " << *answer << std::endl;
}

TEST(day_2, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 60948);
    std::cout << "part two: " << *answer << std::endl;
}

TEST(day_2, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 8);
    std::cout << "part one sample: " << *answer << std::endl;
}

TEST(day_2, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 2286);
    std::cout << "part two sample: " << *answer << std::endl;
}
