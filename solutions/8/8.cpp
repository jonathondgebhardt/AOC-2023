// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <functional>
#include <gtest/gtest.h>
#include <numeric>

struct Node
{
    explicit Node(const std::string location) : mLocation(location)
    {
    }

    bool operator==(const Node& other) const
    {
        return mLocation == other.mLocation;
    }

    std::string mLocation;
};

template <> struct std::hash<Node>
{
    std::size_t operator()(const Node& n) const
    {
        return std::hash<std::string>{}(n.mLocation);
    }
};

namespace
{
    struct DesertMap
    {
        static DesertMap Build(const std::vector<std::string>& x)
        {
            DesertMap dm;

            // RL
            dm.mDirections = x.front();

            // AAA = (BBB, CCC)
            // LOCATION = (LEFT, RIGHT)
            for(auto i = 2; i < x.size(); ++i)
            {
                const auto& line = x[i];
                const auto tokens = util::Split(line);

                Node location{tokens[0]};
                Node left{tokens[2].substr(1, tokens[2].size() - 2)};
                Node right{tokens[3].substr(0, tokens[3].size() - 1)};

                dm.mMap.insert({location, std::make_pair(left, right)});
            }

            return dm;
        }

        std::unordered_map<Node, std::pair<Node, Node>> mMap;
        std::string mDirections;
    };

    struct Navigator
    {
        Navigator(const DesertMap& dm, const Node& start) : mDm(dm), mCurrent(start)
        {
        }

        void step()
        {
            ++mSteps;

            const auto next = mDm.mMap.find(mCurrent);
            assert(next != mDm.mMap.end());

            const auto direction = mDm.mDirections[mCurrentDirectionPos];
            mCurrent = direction == 'L' ? next->second.first : next->second.second;

            mDone = mCurrent.mLocation.back() == 'Z';

            ++mCurrentDirectionPos;
            mCurrentDirectionPos %= mDm.mDirections.size();
        }

        int64_t navigate()
        {
            while(!mDone)
            {
                step();
            }

            return mSteps;
        }

        DesertMap mDm;
        Node mCurrent;
        int64_t mSteps{0};
        size_t mCurrentDirectionPos{0};
        bool mDone{false};
    };

    int64_t lcm(std::vector<int64_t> x)
    {
        while(x.size() > 2)
        {
            const auto lhs = x.back();
            x.pop_back();

            const auto rhs = x.back();
            x.pop_back();

            x.push_back(std::lcm(lhs, rhs));
        }

        return std::lcm(x.front(), x.back());
    }

    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            Navigator nav{DesertMap::Build(mInput), Node{"AAA"}};
            return nav.navigate();
        }

        Answer solvePartTwo() override
        {
            const auto map = DesertMap::Build(mInput);

            std::vector<Navigator> navs;
            for(const auto& it : map.mMap)
            {
                if(it.first.mLocation.back() == 'A')
                {
                    navs.emplace_back(map, it.first);
                }
            }

            std::vector<int64_t> steps;
            std::transform(navs.begin(), navs.end(), std::back_inserter(steps),
                           [](Navigator& n) { return n.navigate(); });
            return ::lcm(steps);
        }
    };

    Solver CreateSolver(const std::string& inputFile)
    {
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_8, part_1)
{
    const auto answer = CreateSolver("8.txt").solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 11567);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_8, part_2)
{
    const auto answer = CreateSolver("8.txt").solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 9858474970153);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_8, sample_part_1)
{
    const auto answer = CreateSolver("8_sample_part1.txt").solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 2);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_8, sample_part_2)
{
    const auto answer = CreateSolver("8_sample_part2.txt").solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 6);
    std::cout << "[::::::::::] " << *answer << std::endl;
}
