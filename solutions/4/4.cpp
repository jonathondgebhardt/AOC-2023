// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <algorithm>
#include <gtest/gtest.h>
#include <numeric>

namespace
{
    struct Solver : public ACSolver
    {
        struct ScratchCard
        {
            static ScratchCard Build(const std::string& x)
            {
                ScratchCard sc;

                const auto halves = util::Split(x, '|');
                assert(halves.size() == 2);

                const auto& rhs = halves.back();
                const auto numbers = util::Split(rhs);
                std::transform(numbers.begin(), numbers.end(), std::back_inserter(sc.mNumbers),
                               [](const std::string& str) { return util::StringTo<size_t>(str); });

                const auto& lhs = halves.front();

                const auto colon = lhs.find(':');
                assert(colon != std::string::npos);

                const auto cardNumber = util::Split(lhs.substr(0, colon));
                sc.mCardNumber = util::StringTo<size_t>(cardNumber.back());

                const auto winningNumbers = util::Split(lhs.substr(colon + 1));
                std::transform(winningNumbers.begin(), winningNumbers.end(),
                               std::back_inserter(sc.mWinningNumbers),
                               [](const std::string& str) { return util::StringTo<size_t>(str); });

                for(const auto number : sc.mNumbers)
                {
                    const auto winningNumber = std::any_of(
                        sc.mWinningNumbers.begin(), sc.mWinningNumbers.end(),
                        [number](int64_t winningNumber) { return number == winningNumber; });
                    if(winningNumber)
                    {
                        sc.mScore = sc.mScore == 0 ? 1 : sc.mScore * 2;
                        ++sc.mNumWinning;
                    }
                }

                return sc;
            }

            std::vector<size_t> mWinningNumbers;
            std::vector<size_t> mNumbers;
            int64_t mScore{0};
            size_t mNumWinning{0};
            size_t mCardNumber{0};
        };

        static int64_t GetNumberOfCopies(const ScratchCard& sc,
                                         const std::vector<ScratchCard>& cards)
        {
            int64_t copies{static_cast<int64_t>(sc.mNumWinning)};

            for(auto i = 0; i < sc.mNumWinning; ++i)
            {
                const auto& copy = cards[sc.mCardNumber + i];
                copies += GetNumberOfCopies(copy, cards);
            }

            return copies;
        }

        Answer solvePartOne() override
        {
            std::vector<ScratchCard> cards;
            std::transform(mInput.begin(), mInput.end(), std::back_inserter(cards),
                           &ScratchCard::Build);
            return std::accumulate(cards.begin(), cards.end(), int64_t{0},
                                   [](int64_t sum, const ScratchCard& sc)
                                   { return sum + sc.mScore; });
        }

        Answer solvePartTwo() override
        {
            std::vector<ScratchCard> cards;
            std::transform(mInput.begin(), mInput.end(), std::back_inserter(cards),
                           &ScratchCard::Build);
            return cards.size() + std::accumulate(cards.begin(), cards.end(), int64_t{0},
                                                  [&cards](int64_t sum, const ScratchCard& sc)
                                                  { return sum + GetNumberOfCopies(sc, cards); });
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "4_sample.txt" : "4.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_4, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 24848);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_4, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 7258152);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_4, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 13);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_4, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 30);
    std::cout << "[::::::::::] " << *answer << std::endl;
}
