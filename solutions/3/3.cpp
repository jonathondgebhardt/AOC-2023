// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <gtest/gtest.h>

namespace
{
    struct Solver : public ACSolver
    {
        struct Machine
        {
            struct Item
            {
                bool isAdjacent(const Item& x) const
                {
                    const auto absdiff = [](size_t first, size_t second)
                    { return std::abs(static_cast<int>(first) - static_cast<int>(second)); };

                    if(absdiff(row, x.row) <= 1)
                    {
                        return (start <= x.end && start >= x.start) ||
                               (end <= x.end && end >= x.start);
                    }

                    return false;
                }

                std::string thing;
                size_t start{0};
                size_t end{0}; // end is inclusive
                size_t row{0};
                bool isStar{false};
            };

            void dump() const
            {
                for(const auto& item : items)
                {
                    std::cout << item.thing << " (" << item.row << ", " << item.start << ", "
                              << item.end << ")\n";
                }
            }

            std::vector<Item> getStars() const
            {
                std::vector<Item> stars;
                std::copy_if(items.begin(), items.end(), std::back_inserter(stars),
                             [](const Item& i) { return i.isStar; });
                return stars;
            }

            std::vector<Item> getNumbers() const
            {
                std::vector<Item> numbers;
                std::copy_if(items.begin(), items.end(), std::back_inserter(numbers),
                             [](const Item& i) { return !i.isStar; });
                return numbers;
            }

            std::vector<Item> items;
        };

        bool getIsPartNumber(size_t begin, size_t end, size_t row)
        {
            const auto isSymbol = [](const char c)
            { return c != '.' && std::ispunct(static_cast<unsigned char>(c)); };

            assert(begin < end);

            // TODO: Can I use regex instead?
            // For all characters between begin and end:
            for(auto i = begin; i < end; ++i)
            {
                // North
                if(static_cast<int>(row - 1) >= 0)
                {
                    const auto& previousRow = mInput[row - 1];

                    // NW (i - 1)(row - 1)
                    if(static_cast<int>(i - 1) >= 0 && isSymbol(previousRow[i - 1]))
                    {
                        return true;
                    }

                    // N (i)(row - 1)
                    if(isSymbol(previousRow[i]))
                    {
                        return true;
                    }

                    // NE (i + 1)(row - 1)
                    if(i + 1 < previousRow.size() && isSymbol(previousRow[i + 1]))
                    {
                        return true;
                    }
                }

                {
                    const auto& currentRow = mInput[row];

                    // E (i + 1)(row)
                    if(i + 1 < currentRow.size() && isSymbol(currentRow[i + 1]))
                    {
                        return true;
                    }

                    // W (i - 1)(row
                    if(static_cast<int>(i - 1) >= 0 && isSymbol(currentRow[i - 1]))
                    {
                        return true;
                    }
                }

                // South
                if(row + 1 < mInput.size())
                {
                    const auto& nextRow = mInput[row + 1];

                    // SW (i - 1)(row + 1)
                    if(static_cast<int>(i - 1) >= 0 && isSymbol(nextRow[i - 1]))
                    {
                        return true;
                    }

                    // S (i)(row + 1)
                    if(isSymbol(nextRow[i]))
                    {
                        return true;
                    }

                    // SE (i + 1)(row + 1)
                    if(i + 1 < nextRow.size() && isSymbol(nextRow[i + 1]))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        // I had an idea to use regex to find numbers in a line. Each submatch would be a different
        // number. Then I could build a string based on the surrounding characters (N, S, E, W, etc)
        // and use regex to check if there are any "symbols". I think this solution would be a
        // little simpler but it may not be performant due to regex.
        Answer solvePartOne() override
        {
            int64_t answer{0};

            for(auto i = 0; i < mInput.size(); ++i)
            {
                const auto& line = mInput[i];
                std::optional<size_t> numberStart;
                std::optional<size_t> numberEnd;
                for(auto j = 0; j < line.size(); ++j)
                {
                    if(std::isdigit(static_cast<unsigned char>(line[j])))
                    {
                        if(numberStart.has_value())
                        {
                            numberEnd = j + 1;
                        }
                        else
                        {
                            numberStart = j;

                            // The number may be one digit long.
                            numberEnd = j + 1;
                        }
                    }

                    // TODO: Kinda gross. I don't like repeating the inverse of the previous
                    // conditional. We can't use an else though.
                    // If we have a start and end and we found a non-number or we're at the end of
                    // the line, check if this number is a part number.
                    if((!std::isdigit(static_cast<unsigned char>(line[j])) ||
                        j == line.size() - 1) &&
                       numberStart.has_value() && numberEnd.has_value())
                    {
                        if(getIsPartNumber(*numberStart, *numberEnd, i))
                        {
                            const auto length = *numberEnd - *numberStart;
                            const auto number =
                                util::StringTo<int64_t>(line.substr(*numberStart, length));
                            answer += number;
                        }

                        numberStart.reset();
                        numberEnd.reset();
                    }
                }
            }

            return answer;
        }

        Answer solvePartTwo() override
        {
            Machine m;

            for(auto i = 0; i < mInput.size(); ++i)
            {
                const auto& line = mInput[i];
                std::optional<size_t> numberStart;
                std::optional<size_t> numberEnd;
                for(auto j = 0; j < line.size(); ++j)
                {
                    // I hate this logic
                    if(std::isdigit(static_cast<unsigned char>(line[j])))
                    {
                        if(numberStart.has_value())
                        {
                            numberEnd = j + 1;
                        }
                        else
                        {
                            numberStart = j;

                            // The number may be one digit long.
                            numberEnd = j + 1;
                        }
                    }
                    else if(line[j] == '*')
                    {
                        Machine::Item item;
                        item.start = j;
                        item.end = j + 1;
                        item.thing = line.substr(item.start, item.end - item.start);
                        item.row = i;
                        item.isStar = true;
                        m.items.push_back(item);
                    }

                    // TODO: Kinda gross. I don't like repeating the inverse of the previous
                    // conditional. We can't use an else though.
                    // If we have a start and end and we found a non-number or we're at the end of
                    // the line, check if this number is a part number.
                    if((!std::isdigit(static_cast<unsigned char>(line[j])) ||
                        j == line.size() - 1) &&
                       numberStart.has_value() && numberEnd.has_value())
                    {
                        Machine::Item item;
                        item.start = *numberStart;
                        item.end = *numberEnd;
                        item.thing = line.substr(item.start, item.end - item.start);
                        item.row = i;
                        m.items.push_back(item);

                        numberStart.reset();
                        numberEnd.reset();
                    }
                }
            }

            const auto stars = m.getStars();
            const auto numbers = m.getNumbers();

            int64_t sum{0};
            for(const auto& star : stars)
            {
                std::vector<Machine::Item> adjacentParts;
                std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(adjacentParts),
                             [&](const Machine::Item& number)
                             {
                                 // We have to do the comparison from the perspective of the star.
                                 // Machine::Item::isAdjacent isn't generic enough.
                                 return star.isAdjacent(number);
                             });

                if(adjacentParts.size() == 2)
                {
                    const auto first = util::StringTo<int64_t>(adjacentParts.front().thing);
                    const auto second = util::StringTo<int64_t>(adjacentParts.back().thing);
                    sum += first * second;
                }
            }

            return sum;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "3_sample.txt" : "3.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_3, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 536576);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_3, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 75741499);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_3, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 4361);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_3, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 467835);
    std::cout << "[::::::::::] " << *answer << std::endl;
}
