// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <gtest/gtest.h>
#include <numeric>

namespace
{
    struct Solver : public ACSolver
    {
        struct Machine
        {
            struct Item
            {
                bool isAdjacent(const Item& x) const
                {
                    const auto absdiff = [](size_t first, size_t second)
                    { return std::abs(static_cast<int>(first) - static_cast<int>(second)); };

                    if(absdiff(mRow, x.mRow) <= 1)
                    {
                        // There's probably a gap in my logic, but the comparison below only works
                        // if you do the comparison from the perpsective of the smaller item.
                        const auto& [smallest, largest] = [&]() -> std::pair<Item, Item>
                        {
                            if(mEnd - mStart < x.mEnd - x.mStart)
                            {
                                return {*this, x};
                            }

                            return {x, *this};
                        }();

                        return (smallest.mStart <= largest.mEnd &&
                                smallest.mStart >= largest.mStart) ||
                               (smallest.mEnd <= largest.mEnd && smallest.mEnd >= largest.mStart);
                    }

                    return false;
                }

                std::string mThing;
                size_t mStart{0};
                size_t mEnd{0}; // end is inclusive
                size_t mRow{0};
            };

            static Machine Build(const std::vector<std::string>& x)
            {
                Machine m;

                for(auto i = 0; i < x.size(); ++i)
                {
                    const auto& line = x[i];
                    auto j = 0;
                    while(j < line.size())
                    {
                        Machine::Item item;
                        item.mStart = j;
                        item.mRow = i;

                        auto c = static_cast<unsigned char>(line[j]);
                        if(std::ispunct(c))
                        {
                            ++j;

                            if(c != '.')
                            {
                                item.mThing = std::string(1, c);
                                item.mEnd = j;
                                m.mSymbols.push_back(item);
                            }

                            continue;
                        }

                        while(std::isdigit(c))
                        {
                            item.mThing += std::string(1, c);

                            ++j;
                            c = static_cast<unsigned char>(line[j]);
                        }

                        item.mEnd = j;
                        m.mNumbers.push_back(item);
                    }
                }

                return m;
            }

            std::vector<Item> mSymbols;
            std::vector<Item> mNumbers;
        };

        Answer solvePartOne() override
        {
            const auto m = Machine::Build(mInput);

            const auto partNumberAccumulator = [&m](int64_t sum, const Machine::Item& number)
            {
                const auto isPartNumber = std::any_of(m.mSymbols.begin(), m.mSymbols.end(),
                                                      [&number](const Machine::Item& symbol)
                                                      { return number.isAdjacent(symbol); });
                return isPartNumber ? sum + util::StringTo<int64_t>(number.mThing) : sum;
            };
            return std::accumulate(m.mNumbers.begin(), m.mNumbers.end(), 0, partNumberAccumulator);
        }

        Answer solvePartTwo() override
        {
            const auto m = Machine::Build(mInput);

            std::vector<Machine::Item> stars;
            std::copy_if(m.mSymbols.begin(), m.mSymbols.end(), std::back_inserter(stars),
                         [](const Machine::Item& symbol) { return symbol.mThing == "*"; });

            int64_t gearRatio{0};

            for(const auto& star : stars)
            {
                std::vector<Machine::Item> adjacentParts;
                std::copy_if(
                    m.mNumbers.begin(), m.mNumbers.end(), std::back_inserter(adjacentParts),
                    [&star](const Machine::Item& number) { return number.isAdjacent(star); });
                if(adjacentParts.size() == 2)
                {
                    const auto part1 = util::StringTo<int64_t>(adjacentParts.front().mThing);
                    const auto part2 = util::StringTo<int64_t>(adjacentParts.back().mThing);
                    gearRatio += part1 * part2;
                }
            }

            return gearRatio;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "3_sample.txt" : "3.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_3, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 536576);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_3, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 75741499);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_3, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 4361);
    std::cout << "[::::::::::] " << *answer << std::endl;
}

TEST(day_3, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 467835);
    std::cout << "[::::::::::] " << *answer << std::endl;
}
